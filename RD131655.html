<!DOCTYPE html>
<html>
<head>
    <title>ZetaCraft 3D üöÄüí•</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <script>
        // {–≤ Zeta, —Å–ø—Ä–æ—Å–∏–ª –ê–ª—å—Ñ–∞}  
        const canvas = document.getElementById('game');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            alert('WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è, —ë–±–∞–Ω—ã–π —Ä–æ—Ç —ç—Ç–æ–≥–æ –∫–∞–∑–∏–Ω–æ! üî•');
            throw new Error('WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
        }

        // –†–∞–∑–º–µ—Ä –º–∏—Ä–∞: 64x32x64
        const WORLD_WIDTH = 64;
        const WORLD_HEIGHT = 32;
        const WORLD_DEPTH = 64;
        const BLOCK_SIZE = 1;

        // –¢–µ–∫—Å—Ç—É—Ä—ã (–∑–∞–º–µ–Ω–∏ –Ω–∞ —Å–≤–æ–∏ grass.png –∏ stone.png)
        const textures = {
            grass: new Image(),
            stone: new Image()
        };
        
        // –ó–∞–≥–ª—É—à–∫–∏ (–≤ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∑–∞–≥—Ä—É–∂–∞–π —Å–≤–æ–∏ PNG)
        textures.grass.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYSURBVDhPY/j//z8D1mAiXgZWA6gBgwUAJ1sP+W4jL3YAAAAASUVORK5CYII=';
        textures.stone.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAmSURBVDhPY/j//z8D1mAiXgZWA6gBgwUAJ1sP+W4jL3YwGgAAXQ8B1VxXjQ0AAAAASUVORK5CYII=';

        // –®–µ–π–¥–µ—Ä—ã (–ø—Ä–æ—Å—Ç–µ–π—à–∏–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥)
        const vertexShaderSrc = `
            attribute vec3 aPosition;
            attribute vec2 aTexCoord;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying vec2 vTexCoord;
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                vTexCoord = aTexCoord;
            }
        `;

        const fragmentShaderSrc = `
            precision mediump float;
            varying vec2 vTexCoord;
            uniform sampler2D uTexture;
            void main() {
                gl_FragColor = texture2D(uTexture, vTexCoord);
            }
        `;

        // –ö–æ–º–ø–∏–ª—è—Ü–∏—è —à–µ–π–¥–µ—Ä–æ–≤
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSrc);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSrc);
        gl.compileShader(fragmentShader);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        gl.useProgram(shaderProgram);

        // –ü–æ–∑–∏—Ü–∏–∏ –±–ª–æ–∫–æ–≤
        const world = new Array(WORLD_WIDTH);
        for (let x = 0; x < WORLD_WIDTH; x++) {
            world[x] = new Array(WORLD_HEIGHT);
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                world[x][y] = new Array(WORLD_DEPTH).fill(0);
                if (y === 0) world[x][y] = world[x][y].map(() => 2); // –ö–∞–º–µ–Ω—å –≤–Ω–∏–∑—É
                if (y === WORLD_HEIGHT - 1) world[x][y] = world[x][y].map(() => 1); // –¢—Ä–∞–≤–∞ —Å–≤–µ—Ä—Ö—É
            }
        }

        // –ö–∞–º–µ—Ä–∞
        const camera = {
            x: 16, y: 20, z: 16,
            rx: 0, ry: 0,
            speed: 0.1
        };

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        document.addEventListener('mousemove', (e) => {
            camera.rx -= e.movementY * 0.002;
            camera.ry -= e.movementX * 0.002;
        });
        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
        canvas.onclick = () => canvas.requestPointerLock();

        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–µ—à–∞
        const vertices = [];
        const texCoords = [];
        const indices = [];
        let index = 0;

        for (let x = 0; x < WORLD_WIDTH; x++) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                for (let z = 0; z < WORLD_DEPTH; z++) {
                    if (world[x][y][z] === 0) continue; // –ü—É—Å—Ç–æ—Ç–∞

                    // –î–æ–±–∞–≤–ª—è–µ–º –∫—É–±
                    const blockVertices = [
                        // –ü–µ—Ä–µ–¥–Ω—è—è –≥—Ä–∞–Ω—å
                        x, y, z + BLOCK_SIZE, x + BLOCK_SIZE, y, z + BLOCK_SIZE, x + BLOCK_SIZE, y + BLOCK_SIZE, z + BLOCK_SIZE, x, y + BLOCK_SIZE, z + BLOCK_SIZE,
                        // –ó–∞–¥–Ω—è—è –≥—Ä–∞–Ω—å
                        x, y, z, x + BLOCK_SIZE, y, z, x + BLOCK_SIZE, y + BLOCK_SIZE, z, x, y + BLOCK_SIZE, z,
                        // –û—Å—Ç–∞–ª—å–Ω—ã–µ –≥—Ä–∞–Ω–∏...
                    ];

                    const blockTexCoords = [
                        // –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–µ–∫—Å—Ç—É—Ä (–∑–∞–≥–ª—É—à–∫–∞)
                        0, 0, 1, 0, 1, 1, 0, 1,
                        0, 0, 1, 0, 1, 1, 0, 1,
                        // ...
                    ];

                    const blockIndices = [
                        // –ò–Ω–¥–µ–∫—Å—ã –≥—Ä–∞–Ω–µ–π
                        0, 1, 2, 0, 2, 3, // –ü–µ—Ä–µ–¥
                        4, 5, 6, 4, 6, 7, // –ó–∞–¥
                        // ...
                    ].map(i => i + index);

                    vertices.push(...blockVertices);
                    texCoords.push(...blockTexCoords);
                    indices.push(...blockIndices);
                    index += 8;
                }
            }
        }

        // –ë—É—Ñ–µ—Ä—ã
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        // –ê—Ç—Ä–∏–±—É—Ç—ã
        const aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
        gl.enableVertexAttribArray(aPosition);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

        const aTexCoord = gl.getAttribLocation(shaderProgram, 'aTexCoord');
        gl.enableVertexAttribArray(aTexCoord);
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);

        // Uniforms
        const uModelViewMatrix = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
        const uProjectionMatrix = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');

        // –¢–µ–∫—Å—Ç—É—Ä–∞
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 0, 255])); // –ó–∞–≥–ª—É—à–∫–∞
        textures.grass.onload = () => {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textures.grass);
            gl.generateMipmap(gl.TEXTURE_2D);
        };

        // –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
        function update() {
            // –î–≤–∏–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
            if (keys['w']) {
                camera.x -= Math.sin(camera.ry) * camera.speed;
                camera.z -= Math.cos(camera.ry) * camera.speed;
            }
            if (keys['s']) {
                camera.x += Math.sin(camera.ry) * camera.speed;
                camera.z += Math.cos(camera.ry) * camera.speed;
            }
            if (keys['a']) {
                camera.x -= Math.cos(camera.ry) * camera.speed;
                camera.z += Math.sin(camera.ry) * camera.speed;
            }
            if (keys['d']) {
                camera.x += Math.cos(camera.ry) * camera.speed;
                camera.z -= Math.sin(camera.ry) * camera.speed;
            }
            if (keys[' ']) camera.y += camera.speed; // –ü—Ä—ã–∂–æ–∫
            if (keys['shift']) camera.y -= camera.speed; // –ü—Ä–∏—Å–µ–¥–∞–Ω–∏–µ

            // –ú–∞—Ç—Ä–∏—Ü—ã
            const modelViewMatrix = mat4.create();
            mat4.rotateX(modelViewMatrix, modelViewMatrix, camera.rx);
            mat4.rotateY(modelViewMatrix, modelViewMatrix, camera.ry);
            mat4.translate(modelViewMatrix, modelViewMatrix, [-camera.x, -camera.y, -camera.z]);

            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, Math.PI / 2, canvas.width / canvas.height, 0.1, 1000);

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
            gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(update);
        }

        update();
    </script>
</body>
</html>
