<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CaveGame</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: url('background.png') repeat;
    }
    canvas {
      display: block;
      width: 854px;
      height: 480px;
      margin: auto;
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three @0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three @0.160.0/examples/js/controls/PointerLockControls.js"></script>
<script>
const CHUNK_SIZE = 16;
const WORLD_SIZE_X = 64;
const WORLD_SIZE_Y = 32;
const WORLD_SIZE_Z = 64;

let scene, camera, renderer, controls;
let player, velocity = new THREE.Vector3();
let keys = {};
let isOnGround = false;
let raycaster = new THREE.Raycaster();

let textures = {};
let blocks = [];

init();
animate();

function init() {
  // Renderer
  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
  renderer.setSize(854, 480);
  renderer.setPixelRatio(window.devicePixelRatio);

  // Scene
  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x87ceeb, 0.002); // Sky blue fog

  // Camera
  camera = new THREE.PerspectiveCamera(75, 854 / 480, 0.1, 1000);

  // Light
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(10, 20, 10);
  scene.add(directionalLight);

  // Controls
  controls = new THREE.PointerLockControls(camera, document.body);
  document.body.addEventListener('click', () => controls.lock());
  controls.addEventListener('lock', () => console.log("Locked"));
  controls.addEventListener('unlock', () => console.log("Unlocked"));
  scene.add(controls.getObject());

  // Movement
  window.addEventListener('keydown', e => keys[e.code] = true);
  window.addEventListener('keyup', e => keys[e.code] = false);

  // Player
  const geometry = new THREE.BoxGeometry(0.9, 1.8, 0.9);
  const material = new THREE.MeshBasicMaterial({ color: 0xff0000, visible: false });
  player = new THREE.Mesh(geometry, material);
  scene.add(player);

  // Load Textures
  const loader = new THREE.TextureLoader();
  loader.load('stone.png', texture => { textures.stone = texture; });
  loader.load('grass.png', texture => { textures.grass = texture; });

  // Generate World
  setTimeout(generateWorld, 100);
}

function generateWorld() {
  for (let x = 0; x < WORLD_SIZE_X; x++) {
    for (let z = 0; z < WORLD_SIZE_Z; z++) {
      let surfaceY = Math.floor(Math.random() * 3) + 10;
      for (let y = 0; y < WORLD_SIZE_Y; y++) {
        if (y === surfaceY && y > 0) {
          addBlock(x, y, z, 'grass');
        } else if (y < surfaceY) {
          let cave = Math.random() < 0.01 && y > 2;
          if (!cave) addBlock(x, y, z, 'stone');
        }
      }
    }
  }
}

function addBlock(x, y, z, type) {
  const material = new THREE.MeshBasicMaterial({ map: textures[type] });
  const geometry = new THREE.BoxGeometry(1, 1, 1);
  const block = new THREE.Mesh(geometry, material);
  block.position.set(x - WORLD_SIZE_X / 2, y, z - WORLD_SIZE_Z / 2);
  scene.add(block);
  blocks.push(block);
}

function teleportRandom() {
  let x = Math.floor(Math.random() * WORLD_SIZE_X) - WORLD_SIZE_X / 2;
  let z = Math.floor(Math.random() * WORLD_SIZE_Z) - WORLD_SIZE_Z / 2;
  for (let y = WORLD_SIZE_Y; y >= 0; y--) {
    const block = getBlockAt(x, y, z);
    if (block && block.material.map === textures.grass) {
      controls.getObject().position.set(x + 0.5, y + 2, z + 0.5);
      velocity.set(0, 0, 0);
      return;
    }
  }
}

function getBlockAt(x, y, z) {
  for (let b of blocks) {
    if (Math.abs(b.position.x - x) < 0.1 &&
        Math.abs(b.position.y - y) < 0.1 &&
        Math.abs(b.position.z - z) < 0.1)
      return b;
  }
  return null;
}

function updatePlayerMovement(deltaTime) {
  const speed = 5;
  const move = new THREE.Vector3();

  if (keys['KeyW']) move.z -= 1;
  if (keys['KeyS']) move.z += 1;
  if (keys['KeyA']) move.x -= 1;
  if (keys['KeyD']) move.x += 1;

  move.normalize();
  move.applyEuler(camera.rotation);
  move.y = 0;

  controls.moveRight(move.x * deltaTime * speed);
  controls.moveForward(move.z * deltaTime * speed);

  // Jump
  if (keys['Space'] && isOnGround) {
    velocity.y = 8;
    isOnGround = false;
  }

  // Gravity
  velocity.y -= 9.8 * deltaTime;
  controls.getObject().position.addScaledVector(velocity, deltaTime);

  // Collision detection
  const pos = controls.getObject().position.clone();
  const feetPos = pos.clone().add(new THREE.Vector3(0, -1, 0));
  const headPos = pos.clone().add(new THREE.Vector3(0, 1, 0));

  raycaster.set(pos, new THREE.Vector3(0, -1, 0));
  const intersects = raycaster.intersectObjects(blocks);
  if (intersects.length > 0 && intersects[0].distance < 0.5) {
    if (velocity.y <= 0) {
      velocity.y = 0;
      isOnGround = true;
    }
  }

  // Falling into void
  if (pos.y < -5) {
    isOnGround = true;
    velocity.y = 0;
  }

  // Teleport on R
  if (keys['KeyR']) {
    teleportRandom();
    keys['KeyR'] = false;
  }
}

function animate() {
  requestAnimationFrame(animate);
  const delta = 0.016;
  if (controls.isLocked) {
    updatePlayerMovement(delta);
  }
  renderer.render(scene, camera);
}
</script>
</body>
</html>
