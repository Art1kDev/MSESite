<!DOCTYPE html>
<html>
<head>
    <title>CaveGame</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Цвет неба */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 854px;
            height: 480px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Конфигурация мира
        const WORLD_CONFIG = {
            width: 64,
            height: 64,
            depth: 64,
            stoneHeight: 8,
            caveThreshold: 0.3
        };

        // Инициализация WebGL
        const canvas = document.getElementById('gameCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL не поддерживается вашим браузером!');
            throw new Error('WebGL not supported');
        }

        canvas.width = 854;
        canvas.height = 480;

        // Шейдеры
        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec2 aTexCoord;
            attribute vec3 aNormal;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying vec2 vTexCoord;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
                vTexCoord = aTexCoord;
                vNormal = aNormal;
                vPosition = aPosition;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec2 vTexCoord;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform sampler2D uTexture;
            uniform vec3 uLightDirection;
            
            void main() {
                vec4 texColor = texture2D(uTexture, vTexCoord);
                float ambient = 0.4;
                float diffuse = max(dot(normalize(vNormal), normalize(uLightDirection)) * 0.6;
                float light = min(ambient + diffuse, 1.0);
                
                // Простое затенение в зависимости от высоты (имитация пещер)
                float heightFactor = clamp(vPosition.y / 20.0, 0.3, 1.0);
                
                gl_FragColor = vec4(texColor.rgb * light * heightFactor, texColor.a);
            }
        `;

        // Компиляция шейдеров
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Ошибка компиляции шейдера:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Ошибка линковки программы:', gl.getProgramInfoLog(shaderProgram));
        }

        // Получение атрибутов и униформов
        const programInfo = {
            program: shaderProgram,
            attribLocations: {
                position: gl.getAttribLocation(shaderProgram, 'aPosition'),
                texCoord: gl.getAttribLocation(shaderProgram, 'aTexCoord'),
                normal: gl.getAttribLocation(shaderProgram, 'aNormal'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                texture: gl.getUniformLocation(shaderProgram, 'uTexture'),
                lightDirection: gl.getUniformLocation(shaderProgram, 'uLightDirection'),
            },
        };

        // Создаем простые текстуры программно
        function createTexture(gl, color) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            const level = 0;
            const internalFormat = gl.RGBA;
            const width = 1;
            const height = 1;
            const border = 0;
            const srcFormat = gl.RGBA;
            const srcType = gl.UNSIGNED_BYTE;
            const pixel = new Uint8Array([color[0], color[1], color[2], 255]);
            
            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);
            
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
            
            return texture;
        }

        // Простые текстуры
        const textures = {
            grass: createTexture(gl, [34, 139, 34]), // зеленый
            stone: createTexture(gl, [128, 128, 128]), // серый
            dirt: createTexture(gl, [139, 69, 19]) // коричневый
        };

        // Генерация мира
        class World {
            constructor() {
                this.blocks = new Array(WORLD_CONFIG.width);
                for (let x = 0; x < WORLD_CONFIG.width; x++) {
                    this.blocks[x] = new Array(WORLD_CONFIG.height);
                    for (let y = 0; y < WORLD_CONFIG.height; y++) {
                        this.blocks[x][y] = new Array(WORLD_CONFIG.depth).fill(0);
                    }
                }
                
                this.generateTerrain();
            }
            
            generateTerrain() {
                const { width, height, depth, stoneHeight } = WORLD_CONFIG;
                
                for (let x = 0; x < width; x++) {
                    for (let z = 0; z < depth; z++) {
                        // Генерация высоты поверхности (простой шум)
                        const surfaceHeight = Math.floor(
                            (Math.random() * 0.5 + 0.5) * 20 + height / 4
                        );
                        
                        for (let y = 0; y < height; y++) {
                            if (y > surfaceHeight) {
                                this.blocks[x][y][z] = 0; // воздух
                            } else if (y === surfaceHeight) {
                                this.blocks[x][y][z] = 1; // трава
                            } else if (y > surfaceHeight - 3) {
                                this.blocks[x][y][z] = 3; // земля
                            } else if (y > surfaceHeight - stoneHeight) {
                                this.blocks[x][y][z] = 2; // камень
                            } else {
                                this.blocks[x][y][z] = 2; // камень (глубже)
                            }
                        }
                    }
                }
            }
            
            getBlock(x, y, z) {
                if (x < 0 || x >= WORLD_CONFIG.width || 
                    y < 0 || y >= WORLD_CONFIG.height || 
                    z < 0 || z >= WORLD_CONFIG.depth) {
                    return 0; // за пределами мира - воздух
                }
                return this.blocks[x][y][z];
            }
            
            isSolidBlock(x, y, z) {
                return this.getBlock(x, y, z) !== 0;
            }
        }

        // Игрок
        class Player {
            constructor() {
                this.position = [WORLD_CONFIG.width / 2, WORLD_CONFIG.height + 5, WORLD_CONFIG.depth / 2];
                this.rotation = [0, 0]; // pitch, yaw
                this.velocity = [0, 0, 0];
                this.onGround = false;
                this.speed = 0.1;
                this.jumpForce = 0.2;
                this.height = 1.8;
                this.width = 0.6;
                this.friction = 0.8;
                this.acceleration = 0.2;
            }
            
            update(keys, world) {
                // Гравитация
                if (!this.onGround) {
                    this.velocity[1] -= 0.02;
                }
                
                // Движение
                const moveVector = [0, 0, 0];
                const [pitch, yaw] = this.rotation;
                
                if (keys['w']) {
                    moveVector[0] += Math.sin(yaw) * this.acceleration;
                    moveVector[2] += Math.cos(yaw) * this.acceleration;
                }
                if (keys['s']) {
                    moveVector[0] -= Math.sin(yaw) * this.acceleration;
                    moveVector[2] -= Math.cos(yaw) * this.acceleration;
                }
                if (keys['a']) {
                    moveVector[0] += Math.sin(yaw - Math.PI/2) * this.acceleration;
                    moveVector[2] += Math.cos(yaw - Math.PI/2) * this.acceleration;
                }
                if (keys['d']) {
                    moveVector[0] += Math.sin(yaw + Math.PI/2) * this.acceleration;
                    moveVector[2] += Math.cos(yaw + Math.PI/2) * this.acceleration;
                }
                
                // Применение движения (горизонтальная плоскость)
                this.velocity[0] += moveVector[0];
                this.velocity[2] += moveVector[2];
                
                // Трение
                if (this.onGround) {
                    this.velocity[0] *= this.friction;
                    this.velocity[2] *= this.friction;
                }
                
                // Прыжок
                if (keys[' '] && this.onGround) {
                    this.velocity[1] = this.jumpForce;
                    this.onGround = false;
                }
                
                // Коллизии
                this.handleCollisions(world);
                
                // Обновление позиции
                this.position[0] += this.velocity[0];
                this.position[1] += this.velocity[1];
                this.position[2] += this.velocity[2];
                
                // Ограничение скорости падения
                if (this.velocity[1] < -0.5) {
                    this.velocity[1] = -0.5;
                }
            }
            
            handleCollisions(world) {
                const [px, py, pz] = this.position;
                const [vx, vy, vz] = this.velocity;
                const halfWidth = this.width / 2;
                const halfHeight = this.height / 2;
                
                // Проверка коллизий по Y
                this.onGround = false;
                
                // Проверка под ногами
                if (vy < 0) {
                    for (let dx = -halfWidth; dx <= halfWidth; dx += halfWidth) {
                        for (let dz = -halfWidth; dz <= halfWidth; dz += halfWidth) {
                            const blockX = Math.floor(px + dx);
                            const blockY = Math.floor(py - halfHeight + vy);
                            const blockZ = Math.floor(pz + dz);
                            
                            if (world.isSolidBlock(blockX, blockY, blockZ)) {
                                this.position[1] = blockY + 1 + halfHeight;
                                this.velocity[1] = 0;
                                this.onGround = true;
                                break;
                            }
                        }
                        if (this.onGround) break;
                    }
                }
                
                // Проверка над головой
                if (vy > 0) {
                    for (let dx = -halfWidth; dx <= halfWidth; dx += halfWidth) {
                        for (let dz = -halfWidth; dz <= halfWidth; dz += halfWidth) {
                            const blockX = Math.floor(px + dx);
                            const blockY = Math.floor(py + halfHeight + vy);
                            const blockZ = Math.floor(pz + dz);
                            
                            if (world.isSolidBlock(blockX, blockY, blockZ)) {
                                this.position[1] = blockY - halfHeight;
                                this.velocity[1] = 0;
                                break;
                            }
                        }
                    }
                }
                
                // Проверка коллизий по X
                if (vx !== 0) {
                    for (let dy = -halfHeight; dy <= halfHeight; dy += halfHeight) {
                        for (let dz = -halfWidth; dz <= halfWidth; dz += halfWidth) {
                            const blockX = Math.floor(px + (vx > 0 ? halfWidth : -halfWidth) + vx);
                            const blockY = Math.floor(py + dy);
                            const blockZ = Math.floor(pz + dz);
                            
                            if (world.isSolidBlock(blockX, blockY, blockZ)) {
                                this.velocity[0] = 0;
                                this.position[0] = blockX + (vx > 0 ? -halfWidth : 1 + halfWidth);
                                break;
                            }
                        }
                    }
                }
                
                // Проверка коллизий по Z
                if (vz !== 0) {
                    for (let dy = -halfHeight; dy <= halfHeight; dy += halfHeight) {
                        for (let dx = -halfWidth; dx <= halfWidth; dx += halfWidth) {
                            const blockX = Math.floor(px + dx);
                            const blockY = Math.floor(py + dy);
                            const blockZ = Math.floor(pz + (vz > 0 ? halfWidth : -halfWidth) + vz);
                            
                            if (world.isSolidBlock(blockX, blockY, blockZ)) {
                                this.velocity[2] = 0;
                                this.position[2] = blockZ + (vz > 0 ? -halfWidth : 1 + halfWidth);
                                break;
                            }
                        }
                    }
                }
            }
        }

        // Инициализация мира и игрока
        const world = new World();
        const player = new Player();

        // Управление
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Управление мышью
        let mouseX = 0, mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
            const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
            
            player.rotation[0] -= movementY * 0.002;
            player.rotation[1] -= movementX * 0.002;
            
            // Ограничение вертикального вращения
            player.rotation[0] = Math.max(-Math.PI/2, Math.min(Math.PI/2, player.rotation[0]));
        });

        // Захват мыши
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock = canvas.requestPointerLock || 
                                        canvas.mozRequestPointerLock || 
                                        canvas.webkitRequestPointerLock;
            canvas.requestPointerLock();
        });

        // Создание меша для блока
        function createBlockMesh() {
            const positions = [];
            const texCoords = [];
            const normals = [];
            const indices = [];
            let index = 0;
            
            // Координаты вершин куба
            const vertices = [
                // Передняя грань
                [-0.5, -0.5,  0.5], [ 0.5, -0.5,  0.5], [ 0.5,  0.5,  0.5], [-0.5,  0.5,  0.5],
                // Задняя грань
                [-0.5, -0.5, -0.5], [-0.5,  0.5, -0.5], [ 0.5,  0.5, -0.5], [ 0.5, -0.5, -0.5],
                // Верхняя грань
                [-0.5,  0.5, -0.5], [-0.5,  0.5,  0.5], [ 0.5,  0.5,  0.5], [ 0.5,  0.5, -0.5],
                // Нижняя грань
                [-0.5, -0.5, -0.5], [ 0.5, -0.5, -0.5], [ 0.5, -0.5,  0.5], [-0.5, -0.5,  0.5],
                // Правая грань
                [ 0.5, -0.5, -0.5], [ 0.5,  0.5, -0.5], [ 0.5,  0.5,  0.5], [ 0.5, -0.5,  0.5],
                // Левая грань
                [-0.5, -0.5, -0.5], [-0.5, -0.5,  0.5], [-0.5,  0.5,  0.5], [-0.5,  0.5, -0.5]
            ];
            
            // Нормали для каждой грани
            const faceNormals = [
                [0, 0, 1],    // перед
                [0, 0, -1],    // зад
                [0, 1, 0],     // верх
                [0, -1, 0],    // низ
                [1, 0, 0],     // право
                [-1, 0, 0]     // лево
            ];
            
            // Текстурные координаты
            const faceTexCoords = [
                [0, 0], [1, 0], [1, 1], [0, 1]
            ];
            
            // Индексы для каждой грани
            const faceIndices = [
                [0, 1, 2, 0, 2, 3],    // перед
                [4, 5, 6, 4, 6, 7],    // зад
                [8, 9, 10, 8, 10, 11], // верх
                [12, 13, 14, 12, 14, 15], // низ
                [16, 17, 18, 16, 18, 19], // право
                [20, 21, 22, 20, 22, 23]  // лево
            ];
            
            // Собираем все грани
            for (let face = 0; face < 6; face++) {
                for (let i = 0; i < 4; i++) {
                    positions.push(...vertices[face * 4 + i]);
                    texCoords.push(...faceTexCoords[i]);
                    normals.push(...faceNormals[face]);
                }
                
                for (let i = 0; i < 6; i++) {
                    indices.push(faceIndices[face][i] + face * 4);
                }
            }
            
            return {
                positions: new Float32Array(positions),
                texCoords: new Float32Array(texCoords),
                normals: new Float32Array(normals),
                indices: new Uint16Array(indices),
                vertexCount: indices.length
            };
        }

        // Создаем меш для блока
        const blockMesh = createBlockMesh();

        // Буферы для рендеринга блоков
        const blockBuffers = {
            position: gl.createBuffer(),
            texCoord: gl.createBuffer(),
            normal: gl.createBuffer(),
            index: gl.createBuffer()
        };

        gl.bindBuffer(gl.ARRAY_BUFFER, blockBuffers.position);
        gl.bufferData(gl.ARRAY_BUFFER, blockMesh.positions, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, blockBuffers.texCoord);
        gl.bufferData(gl.ARRAY_BUFFER, blockMesh.texCoords, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER, blockBuffers.normal);
        gl.bufferData(gl.ARRAY_BUFFER, blockMesh.normals, gl.STATIC_DRAW);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, blockBuffers.index);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, blockMesh.indices, gl.STATIC_DRAW);

        // Матричные операции
        const mat4 = {
            create: function() {
                return new Float32Array(16);
            },
            identity: function(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            },
            perspective: function(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) / (near - far);
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) / (near - far);
                out[15] = 0;
                return out;
            },
            translate: function(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                
                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                    
                    out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                    out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                    out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;
                    
                    out[12] = a00 * x + a10 * y + a20 * z + a[12];
                    out[13] = a01 * x + a11 * y + a21 * z + a[13];
                    out[14] = a02 * x + a12 * y + a22 * z + a[14];
                    out[15] = a03 * x + a13 * y + a23 * z + a[15];
                }
                
                return out;
            },
            rotateX: function(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a[4];
                const a11 = a[5];
                const a12 = a[6];
                const a13 = a[7];
                const a20 = a[8];
                const a21 = a[9];
                const a22 = a[10];
                const a23 = a[11];
                
                if (a !== out) {
                    out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }
                
                out[4] = a10 * c + a20 * s;
                out[5] = a11 * c + a21 * s;
                out[6] = a12 * c + a22 * s;
                out[7] = a13 * c + a23 * s;
                
                out[8] = a20 * c - a10 * s;
                out[9] = a21 * c - a11 * s;
                out[10] = a22 * c - a12 * s;
                out[11] = a23 * c - a13 * s;
                
                return out;
            },
            rotateY: function(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0];
                const a01 = a[1];
                const a02 = a[2];
                const a03 = a[3];
                const a20 = a[8];
                const a21 = a[9];
                const a22 = a[10];
                const a23 = a[11];
                
                if (a !== out) {
                    out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                    out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
                }
                
                out[0] = a00 * c - a20 * s;
                out[1] = a01 * c - a21 * s;
                out[2] = a02 * c - a22 * s;
                out[3] = a03 * c - a23 * s;
                
                out[8] = a00 * s + a20 * c;
                out[9] = a01 * s + a21 * c;
                out[10] = a02 * s + a22 * c;
                out[11] = a03 * s + a23 * c;
                
                return out;
            }
        };

        // Рендеринг
        function render() {
            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0.53, 0.81, 0.98, 1.0); // цвет неба
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Матрица проекции
            const projectionMatrix = mat4.create();
            mat4.perspective(
                projectionMatrix,
                45 * Math.PI / 180,
                canvas.width / canvas.height,
                0.1,
                1000.0
            );
            
            // Матрица вида (камеры)
            const modelViewMatrix = mat4.create();
            mat4.rotateX(modelViewMatrix, modelViewMatrix, -player.rotation[0]);
            mat4.rotateY(modelViewMatrix, modelViewMatrix, -player.rotation[1]);
            mat4.translate(modelViewMatrix, modelViewMatrix, [-player.position[0], -player.position[1], -player.position[2]]);
            
            // Рендеринг мира
            gl.useProgram(programInfo.program);
            
            // Установка матриц
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.projectionMatrix,
                false,
                projectionMatrix
            );
            
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.modelViewMatrix,
                false,
                modelViewMatrix
            );
            
            // Направление света
            gl.uniform3fv(
                programInfo.uniformLocations.lightDirection,
                [0.5, 1.0, 0.5] // свет сверху и сбоку
            );
            
            // Включаем атрибуты
            gl.bindBuffer(gl.ARRAY_BUFFER, blockBuffers.position);
            gl.vertexAttribPointer(
                programInfo.attribLocations.position,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );
            gl.enableVertexAttribArray(programInfo.attribLocations.position);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, blockBuffers.texCoord);
            gl.vertexAttribPointer(
                programInfo.attribLocations.texCoord,
                2,
                gl.FLOAT,
                false,
                0,
                0
            );
            gl.enableVertexAttribArray(programInfo.attribLocations.texCoord);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, blockBuffers.normal);
            gl.vertexAttribPointer(
                programInfo.attribLocations.normal,
                3,
                gl.FLOAT,
                false,
                0,
                0
            );
            gl.enableVertexAttribArray(programInfo.attribLocations.normal);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, blockBuffers.index);
            
            // Рендерим видимые блоки
            const renderDistance = 16;
            const [px, py, pz] = player.position.map(Math.floor);
            
            for (let x = Math.max(0, px - renderDistance); x < Math.min(WORLD_CONFIG.width, px + renderDistance); x++) {
                for (let y = Math.max(0, py - renderDistance); y < Math.min(WORLD_CONFIG.height, py + renderDistance); y++) {
                    for (let z = Math.max(0, pz - renderDistance); z < Math.min(WORLD_CONFIG.depth, pz + renderDistance); z++) {
                        const blockType = world.getBlock(x, y, z);
                        
                        if (blockType !== 0) { // 0 = воздух, не рендерим
                            // Проверяем, видна ли хотя бы одна грань блока
                            if (!world.isSolidBlock(x, y+1, z) || !world.isSolidBlock(x, y-1, z) ||
                                !world.isSolidBlock(x+1, y, z) || !world.isSolidBlock(x-1, y, z) ||
                                !world.isSolidBlock(x, y, z+1) || !world.isSolidBlock(x, y, z-1)) {
                                
                                // Выбираем текстуру в зависимости от типа блока
                                let texture;
                                if (blockType === 1) {
                                    texture = textures.grass;
                                } else if (blockType === 2) {
                                    texture = textures.stone;
                                } else {
                                    texture = textures.dirt;
                                }
                                
                                gl.bindTexture(gl.TEXTURE_2D, texture);
                                gl.uniform1i(programInfo.uniformLocations.texture, 0);
                                
                                // Матрица модели (позиция блока)
                                const blockModelViewMatrix = mat4.create();
                                mat4.translate(blockModelViewMatrix, modelViewMatrix, [x, y, z]);
                                gl.uniformMatrix4fv(
                                    programInfo.uniformLocations.modelViewMatrix,
                                    false,
                                    blockModelViewMatrix
                                );
                                
                                // Рисуем блок
                                gl.drawElements(
                                    gl.TRIANGLES,
                                    blockMesh.vertexCount,
                                    gl.UNSIGNED_SHORT,
                                    0
                                );
                            }
                        }
                    }
                }
            }
        }

        // Игровой цикл
        function gameLoop() {
            player.update(keys, world);
            render();
            requestAnimationFrame(gameLoop);
        }

        // Запуск игры
        gameLoop();
    </script>
</body>
</html>
